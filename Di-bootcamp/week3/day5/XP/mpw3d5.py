# -*- coding: utf-8 -*-
"""MPw3d5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n08ziOPGnJ5Z0qUxY2ZkiVqFeRv63bhS
"""

# US Superstore analysis (Excel input) — full notebook code with comments
# Requirements: pandas, numpy, matplotlib, openpyxl (for .xlsx)
# Optional: pip install openpyxl if you run into Excel read errors.

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# # Notebook-friendly display helper (available in this environment)
# try:
#     from caas_jupyter_tools import display_dataframe_to_user
#     display_df = lambda name, df: display_dataframe_to_user(name, df)
# except Exception:
#     display_df = lambda name, df: print(f"DataFrame '{name}' with shape {df.shape}\n{df.head(5)}\n")

from google.colab import files

# Upload file from computer
uploaded = files.upload()

# file name
filename = "US Superstore data.xls"

# Now read xls file
df = pd.read_excel(filename)

# Check first rows
print(df.head())

# -------------------------
# 2) Preprocess dataset
# -------------------------
# Normalize column names: lower-case and underscores
df.columns = [c.strip().lower().replace(" ", "_") for c in df.columns]

# Ensure expected columns exist (based on schema you provided)
expected_cols = [
    "row_id","order_id","order_date","ship_date","ship_mode","customer_id",
    "customer_name","segment","country","city","state","postal_code","region",
    "product_id","category","sub-category","product_name","sales","quantity",
    "discount","profit"
]
# print missing columns if any (not fatal)
missing = [c for c in expected_cols if c not in df.columns]
if missing:
    print("Warning: the following expected columns were not found in the dataset:", missing)
    print("Proceeding with available columns.")

# Convert numeric columns
for col in ["sales","profit","quantity","discount"]:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors="coerce")

# Parse dates
for date_col in ["order_date","ship_date"]:
    if date_col in df.columns:
        df[date_col] = pd.to_datetime(df[date_col], errors="coerce")

# Drop rows lacking sales or profit (can't analyze these rows)
required = [c for c in ["sales","profit"] if c in df.columns]
df = df.dropna(subset=required)

print("Loaded and preprocessed dataset: rows =", len(df), "columns =", len(df.columns))
display_df("Preview", df.head())

# -------------------------
# 3) Which states have the most sales?
# -------------------------
if "state" in df.columns:
    state_sales = df.groupby("state", as_index=False).agg(
        total_sales = ("sales","sum"),
        total_profit = ("profit","sum"),
        orders_count = ("order_id" if "order_id" in df.columns else "customer_id","nunique")
    ).sort_values("total_sales", ascending=False).reset_index(drop=True)
    display_df("States by total sales (sorted)", state_sales.head(50))
    # Plot top 15 states by sales
    top_n = 15
    top_states = state_sales.head(top_n).sort_values("total_sales")
    fig, ax = plt.subplots(figsize=(10,6))
    ax.barh(top_states["state"], top_states["total_sales"])
    ax.set_xlabel("Total Sales (USD)")
    ax.set_title(f"Top {top_n} States by Total Sales")
    plt.tight_layout()
    plt.show()
else:
    raise KeyError("Column 'state' not found — cannot compute state aggregates.")

# -------------------------
# 4) Compare New York vs California (sales & profit)
# -------------------------
def summarize_state(s):
    if "state" not in df.columns:
        return None
    sub = df[df["state"]==s]
    return {
        "state": s,
        "total_sales": sub["sales"].sum(),
        "total_profit": sub["profit"].sum(),
        "rows": len(sub)
    }

ny = summarize_state("New York")
ca = summarize_state("California")
print("New York summary:", ny)
print("California summary:", ca)

# side-by-side bar chart
labels = ["New York","California"]
sales_vals = [ny["total_sales"], ca["total_sales"]]
profit_vals = [ny["total_profit"], ca["total_profit"]]

x = np.arange(len(labels))
width = 0.35
fig, ax = plt.subplots(figsize=(8,5))
ax.bar(x - width/2, sales_vals, width, label="Sales")
ax.bar(x + width/2, profit_vals, width, label="Profit")
ax.set_xticks(x); ax.set_xticklabels(labels)
ax.set_ylabel("USD")
ax.set_title("New York vs California: Total Sales and Profit")
ax.legend()
plt.tight_layout()
plt.show()

# -------------------------
# 5) Outstanding customer in New York
# -------------------------
if "customer_name" in df.columns:
    ny_customers = (
        df[df["state"]=="New York"]
        .groupby("customer_name", as_index=False)
        .agg(total_sales=("sales","sum"), total_profit=("profit","sum"), orders=("order_id" if "order_id" in df.columns else "sales","count"))
        .sort_values("total_profit", ascending=False)
        .reset_index(drop=True)
    )
    display_df("Top NY customers by profit", ny_customers.head(20))
    if len(ny_customers)>0:
        top_ny = ny_customers.iloc[0]
        print(f"Outstanding NY customer by profit: {top_ny['customer_name']} — Profit=${top_ny['total_profit']:,.2f}, Sales=${top_ny['total_sales']:,.2f}")
else:
    print("customer_name column not present — cannot compute outstanding customer in New York.")

# -------------------------
# 6) Are there differences among states in profitability?
# -------------------------
# profit margin = total_profit / total_sales (handle division safely)
state_sales["profit_margin"] = state_sales.apply(lambda r: (r["total_profit"] / r["total_sales"]) if r["total_sales"] and not pd.isna(r["total_sales"]) else np.nan, axis=1)
display_df("States sorted by profit margin (top 20)", state_sales.sort_values("profit_margin", ascending=False).head(20))
display_df("States sorted by profit margin (bottom 20)", state_sales.sort_values("profit_margin", ascending=True).head(20))

# Plot state profit margins (top 20 by margin)
fig, ax = plt.subplots(figsize=(12,6))
sm = state_sales.sort_values("profit_margin", ascending=False).head(20)
ax.bar(sm["state"], sm["profit_margin"])
ax.set_xticklabels(sm["state"], rotation=45, ha='right')
ax.set_ylabel("Profit Margin (profit / sales)")
ax.set_title("Top 20 States by Profit Margin")
plt.tight_layout()
plt.show()

# -------------------------
# 7) Pareto Principle: customers vs Profit
# -------------------------
if "customer_name" in df.columns:
    cust_profit = (
        df.groupby("customer_name", as_index=False)
          .agg(total_profit=("profit","sum"), total_sales=("sales","sum"), transactions=("order_id" if "order_id" in df.columns else "sales","count"))
          .sort_values("total_profit", ascending=False)
          .reset_index(drop=True)
    )
    cust_profit["cum_profit"] = cust_profit["total_profit"].cumsum()
    total_profit = cust_profit["total_profit"].sum()
    cust_profit["cum_profit_pct"] = cust_profit["cum_profit"] / total_profit * 100
    cust_profit["rank"] = np.arange(1, len(cust_profit)+1)
    cust_profit["cust_pct"] = cust_profit["rank"] / len(cust_profit) * 100

    # find how many % of customers needed to reach >=80% of profit
    idx80 = (cust_profit["cum_profit_pct"] >= 80).idxmax()  # index of first >=80
    pct_customers_for_80_profit = cust_profit.loc[idx80, "cust_pct"]
    print(f"{pct_customers_for_80_profit:.2f}% of customers account for {cust_profit.loc[idx80,'cum_profit_pct']:.2f}% of profit.")

    display_df("Top customers by profit (top 20)", cust_profit.head(20))

    # Pareto plot (Customers % vs Cumulative Profit %)
    fig, ax = plt.subplots(figsize=(10,6))
    ax.plot(cust_profit["cust_pct"].values, cust_profit["cum_profit_pct"].values, marker='o', linestyle='-')
    ax.set_xlabel("Cumulative % of Customers")
    ax.set_ylabel("Cumulative % of Profit")
    ax.set_title("Pareto Curve — Customers vs Cumulative Profit")
    ax.axhline(80, linestyle='--'); ax.axvline(20, linestyle='--')
    plt.grid(True, linewidth=0.3)
    plt.tight_layout()
    plt.show()
else:
    print("customer_name column missing — skipping Pareto analysis for profit.")

# -------------------------
# 8) Top 20 cities by Sales and by Profit — differences in profitability
# -------------------------
if "city" in df.columns:
    city_summary = (
        df.groupby("city", as_index=False)
          .agg(total_sales=("sales","sum"), total_profit=("profit","sum"), orders=("order_id" if "order_id" in df.columns else "sales","count"))
          .sort_values("total_sales", ascending=False)
          .reset_index(drop=True)
    )
    top20_sales_cities = city_summary.head(20)
    top20_profit_cities = city_summary.sort_values("total_profit", ascending=False).head(20)

    display_df("Top 20 cities by Sales", top20_sales_cities)
    display_df("Top 20 cities by Profit", top20_profit_cities)

    # Compare Sales vs Profit for top sales cities
    fig, ax = plt.subplots(figsize=(12,6))
    x = np.arange(len(top20_sales_cities))
    ax.bar(x - 0.2, top20_sales_cities["total_sales"], width=0.4, label="Sales")
    ax.bar(x + 0.2, top20_sales_cities["total_profit"], width=0.4, label="Profit")
    ax.set_xticks(x); ax.set_xticklabels(top20_sales_cities["city"], rotation=70, ha='right')
    ax.set_title("Top 20 Cities by Sales: Sales vs Profit")
    ax.legend()
    plt.tight_layout()
    plt.show()

    # Profit margin for those top cities
    top20_sales_cities["profit_margin"] = top20_sales_cities.apply(lambda r: (r["total_profit"]/r["total_sales"]) if r["total_sales"] and not pd.isna(r["total_sales"]) else np.nan, axis=1)
    display_df("Top 20 sales cities with profit margin", top20_sales_cities[["city","total_sales","total_profit","profit_margin"]])
else:
    print("Column 'city' missing — cannot compute city-level analysis.")

# -------------------------
# 9) Top 20 customers by Sales
# -------------------------
if "customer_name" in df.columns:
    top20_cust_sales = (
        df.groupby("customer_name", as_index=False)
          .agg(total_sales=("sales","sum"), total_profit=("profit","sum"))
          .sort_values("total_sales", ascending=False)
          .head(20)
          .reset_index(drop=True)
    )
    display_df("Top 20 customers by Sales", top20_cust_sales)
else:
    print("customer_name column missing — cannot compute top customers by sales.")

# -------------------------
# 10) Cumulative Sales curve by Customers (Pareto on Sales)
# -------------------------
if "customer_name" in df.columns:
    cust_sales = (
        df.groupby("customer_name", as_index=False)
          .agg(total_sales=("sales","sum"))
          .sort_values("total_sales", ascending=False)
          .reset_index(drop=True)
    )
    cust_sales["cum_sales"] = cust_sales["total_sales"].cumsum()
    total_sales_all = cust_sales["total_sales"].sum()
    cust_sales["cum_sales_pct"] = cust_sales["cum_sales"] / total_sales_all * 100
    cust_sales["rank"] = np.arange(1, len(cust_sales)+1)
    cust_sales["cust_pct"] = cust_sales["rank"] / len(cust_sales) * 100

    idx80_sales = (cust_sales["cum_sales_pct"] >= 80).idxmax()
    pct_customers_for_80_sales = cust_sales.loc[idx80_sales, "cust_pct"]
    print(f"{pct_customers_for_80_sales:.2f}% of customers account for {cust_sales.loc[idx80_sales,'cum_sales_pct']:.2f}% of total sales.")

    # Plot cumulative sales Pareto curve
    fig, ax = plt.subplots(figsize=(10,6))
    ax.plot(cust_sales["cust_pct"], cust_sales["cum_sales_pct"], marker='o', linestyle='-')
    ax.set_xlabel("Cumulative % of Customers")
    ax.set_ylabel("Cumulative % of Sales")
    ax.set_title("Pareto Curve — Customers vs Cumulative Sales")
    ax.axhline(80, linestyle='--'); ax.axvline(20, linestyle='--')
    plt.grid(True, linewidth=0.3)
    plt.tight_layout()
    plt.show()
else:
    print("customer_name column missing — skipping Pareto analysis for sales.")

# -------------------------
# 11) Recommendations: which states / cities to prioritize
# -------------------------
print("\n--- Automatic recommendation rules (simple heuristic) ---")
# Rule: prioritize states with high total sales and positive/strong profit margin.
recommended_states = state_sales.sort_values(["total_sales","profit_margin"], ascending=[False,False]).head(10)
display_df("Recommended states to prioritize", recommended_states)

# For cities, pick those in top sales that also have positive profit_margin
if "city" in df.columns:
    # ensure profit margin computed
    city_summary["profit_margin"] = city_summary.apply(lambda r: (r["total_profit"]/r["total_sales"]) if r["total_sales"] and not pd.isna(r["total_sales"]) else np.nan, axis=1)
    recommended_cities = top20_sales_cities.sort_values(["total_sales","profit_margin"], ascending=[False,False]).head(10)
    display_df("Recommended cities to prioritize", recommended_cities)
else:
    print("No city data — cannot recommend cities.")

# -------------------------
# 12) Optional: Save top outputs to an Excel file for later review
# -------------------------
output_fname = "superstore_analysis_summary.xlsx"
with pd.ExcelWriter(output_fname, engine="openpyxl") as writer:
    state_sales.to_excel(writer, sheet_name="state_sales", index=False)
    if "city" in df.columns:
        city_summary.to_excel(writer, sheet_name="city_summary", index=False)
    if "customer_name" in df.columns:
        cust_profit.to_excel(writer, sheet_name="customer_profit", index=False)
        cust_sales.to_excel(writer, sheet_name="customer_sales", index=False)
    top20_cust_sales.to_excel(writer, sheet_name="top20_customers_by_sales", index=False)
print(f"Saved summary tables to: {output_fname}")

print("\nDone. Use the Excel file and the displayed plots/tables to refine targeting and marketing decisions.")